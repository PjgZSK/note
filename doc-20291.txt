today-todo
1. note
//1. CreatePinataGraphicSpinSlot
//2. public static PinataFeatureGameParas GetDefault()
//3. private IEnumerator PlayPinataMergeAnimation(IEnumerable<Pinata> oldp, IEnumerable<Pinata> newp)


tomorrow-todo


note:
8.
tea activity
    slot activity
        feature game
        save
        step featrue progress
tea activity paras
    slot activity paras
        feature trigger rule
        slot game



pinata:
origin:
1 1 1 1
1 1 1 0
1 1 0 0

x scan:
1 1 1 1
2 2 2 0
3 3 0 0

sum:
1 1 1 1
3 3 3 0
6 6 0 0

repaint:
6 6 3 1
6 6 3 0
6 6 0 0

repaint separated:
6 6 3 7
6 6 3 0
6 6 0 0

origin:
1 1 1 1
1 0 1 0
0 1 0 0

// special
origin:
1 1 1 1
1 1 1 0
1 0 0 0

// special
origin:
0 1 0 0
1 1 0 0
1 1 1 0

todo
b-spline

slot:
SlotLoading.cs :
start - loading packages
LoadGame
SlotMainUI.cs: main ui
SlotGame.cs
_gameBundle - ab resource
_gameView - game main ui
_resultSymbol(List<int>) -> row main (slotgame set2d, get2d)
SlotGameUI.cs
_gameRoot - game main ui

slot key feature:
1. set page's controller
GComponent a                                       ;
a.GetControllerAt(0).SetSelectedPage("halloween");

fairyGUI key feature:
1. load package
//demo就是发布时填写的文件名
UIPackage.AddPackage("demo");
//如果在子目录下
UIPackage.AddPackage("路径/demo");
//如果不放到Resources或者其子目录下，可以传入全路径，但这种方法只能在Editor里使用
UIPackage.AddPackage("Assets/SomePath/Package1");

2. create ui
GComponent view = UIPackage.CreateObject(“包名”, “组件名”).asCom ;
//以下几种方式都可以将view显示出来：
//1，直接加到GRoot显示出来
GRoot.inst.AddChild(view)                                   ;
//2，使用窗口方式显示
aWindow.contentPane = view                                  ;
aWindow.Show()                                              ;
//3，加到其他组件里
aComponnent.AddChild(view)                                  ;

3. resource url
在FairyGUI中，每一个资源都有一个URL地址。
Example: ui://vah15ncrht6g5a

所以我们通常使用另外一种格式：ui://包名/资源名。
Example: ui://MainUI/bg_holloween
注意：“ui://包名/资源名”这个格式的地址是不包含文件夹的，只需要用到包名和资源名。

运行时要获得指定对象的URL地址，可以使用如下方法：
//对象的URL地址
Debug.Log(aObject.resourceURL)                      ;
//对象在资源库中的名称
Debug.Log(aObject.packageItem.name)                 ;
//对象所在包的名称
Debug.Log(aObject.packageItem.owner.name)           ;
//根据URL获得资源名称
Debug.Log(UIPackage.GetItemByURL(resourceURL).name) ;

Coordinate(fairygui -> normal)
local -> local
global -> screen(left, top)

Relation(关联系统)
A -> T (origin -> target)
Origin's graphic property will change with target's graphic property
The key is keep a distance between a property of origin and a property
of target, which will not changed. This distance can be percent
number.

left, mid, right
top, mid, bottom
expand

除了在编辑器设置关联外，有时候我们也需要动态添加关联。例如在一款页游中，一个动态添加到舞台的组件，希望舞台宽度改变时（比如浏览器窗口被玩家拖大拖小），组件依然保持在右侧位置，那么可以这样调用：

aObject.AddRelation(GRoot.inst, RelationType.Right_Right) ;
又例如，一个动态添加到舞台的组件始终保持满屏大小，可以这样调用

aObject.SetSize(GRoot.inst.width, GRoot.inst.height)                                                                                                                     ;
aObject.AddRelation(GRoot.inst, RelationType.Size)                                                                                                                       ;
RelationType.Size相当于RelationType.Width_Width和RelationType.Height_Height的组合。这里强调一下，使组件变为满屏大小这个操作必须由你完成，也就是上面代码中的SetSize调用。关联并不能完成这项任务，因为关联是不管元件当前的大小的，它只会在目标变化时保持两者大小的差别。

删除关联的方法是：

//删除某个关联
aObject.RemoveRelation(targetObject, RelationType.Size) ;

//删除指向某个对象的所有关联
aObject.relations.ClearFor(targetObject) ;
